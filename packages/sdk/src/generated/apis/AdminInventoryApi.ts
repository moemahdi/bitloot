/* tslint:disable */
/* eslint-disable */
/**
 * BitLoot API
 * Crypto-only e-commerce for instant delivery of digital goods
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddInventoryItemDto,
  BulkImportInventoryDto,
  BulkImportResultDto,
  InventoryItemResponseDto,
  InventoryStatsDto,
  PaginatedInventoryDto,
  UpdateItemStatusDto,
} from '../models/index';
import {
    AddInventoryItemDtoFromJSON,
    AddInventoryItemDtoToJSON,
    BulkImportInventoryDtoFromJSON,
    BulkImportInventoryDtoToJSON,
    BulkImportResultDtoFromJSON,
    BulkImportResultDtoToJSON,
    InventoryItemResponseDtoFromJSON,
    InventoryItemResponseDtoToJSON,
    InventoryStatsDtoFromJSON,
    InventoryStatsDtoToJSON,
    PaginatedInventoryDtoFromJSON,
    PaginatedInventoryDtoToJSON,
    UpdateItemStatusDtoFromJSON,
    UpdateItemStatusDtoToJSON,
} from '../models/index';

export interface AdminInventoryControllerAddItemRequest {
    productId: string;
    addInventoryItemDto: AddInventoryItemDto;
}

export interface AdminInventoryControllerBulkImportRequest {
    productId: string;
    bulkImportInventoryDto: BulkImportInventoryDto;
}

export interface AdminInventoryControllerDeleteItemRequest {
    productId: string;
    itemId: string;
}

export interface AdminInventoryControllerGetStatsRequest {
    productId: string;
}

export interface AdminInventoryControllerListItemsRequest {
    productId: string;
    status?: AdminInventoryControllerListItemsStatusEnum;
    supplier?: string;
    page?: number;
    limit?: number;
    sortBy?: AdminInventoryControllerListItemsSortByEnum;
    sortDir?: AdminInventoryControllerListItemsSortDirEnum;
}

export interface AdminInventoryControllerUpdateStatusRequest {
    productId: string;
    itemId: string;
    updateItemStatusDto: UpdateItemStatusDto;
}

/**
 * 
 */
export class AdminInventoryApi extends runtime.BaseAPI {

    /**
     * Add a single digital item (key, account, code, etc.) to a custom product inventory. The item data will be encrypted at rest.
     * Add single item to inventory
     */
    async adminInventoryControllerAddItemRaw(requestParameters: AdminInventoryControllerAddItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryItemResponseDto>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerAddItem().'
            );
        }

        if (requestParameters['addInventoryItemDto'] == null) {
            throw new runtime.RequiredError(
                'addInventoryItemDto',
                'Required parameter "addInventoryItemDto" was null or undefined when calling adminInventoryControllerAddItem().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddInventoryItemDtoToJSON(requestParameters['addInventoryItemDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryItemResponseDtoFromJSON(jsonValue));
    }

    /**
     * Add a single digital item (key, account, code, etc.) to a custom product inventory. The item data will be encrypted at rest.
     * Add single item to inventory
     */
    async adminInventoryControllerAddItem(requestParameters: AdminInventoryControllerAddItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryItemResponseDto> {
        const response = await this.adminInventoryControllerAddItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Import multiple items at once. Optionally skip duplicates. Maximum 1000 items per request.
     * Bulk import items to inventory
     */
    async adminInventoryControllerBulkImportRaw(requestParameters: AdminInventoryControllerBulkImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkImportResultDto>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerBulkImport().'
            );
        }

        if (requestParameters['bulkImportInventoryDto'] == null) {
            throw new runtime.RequiredError(
                'bulkImportInventoryDto',
                'Required parameter "bulkImportInventoryDto" was null or undefined when calling adminInventoryControllerBulkImport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory/bulk`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkImportInventoryDtoToJSON(requestParameters['bulkImportInventoryDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkImportResultDtoFromJSON(jsonValue));
    }

    /**
     * Import multiple items at once. Optionally skip duplicates. Maximum 1000 items per request.
     * Bulk import items to inventory
     */
    async adminInventoryControllerBulkImport(requestParameters: AdminInventoryControllerBulkImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkImportResultDto> {
        const response = await this.adminInventoryControllerBulkImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Permanently delete an available inventory item. Cannot delete reserved or sold items.
     * Delete an inventory item
     */
    async adminInventoryControllerDeleteItemRaw(requestParameters: AdminInventoryControllerDeleteItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerDeleteItem().'
            );
        }

        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling adminInventoryControllerDeleteItem().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory/{itemId}`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));
        urlPath = urlPath.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters['itemId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Permanently delete an available inventory item. Cannot delete reserved or sold items.
     * Delete an inventory item
     */
    async adminInventoryControllerDeleteItem(requestParameters: AdminInventoryControllerDeleteItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminInventoryControllerDeleteItemRaw(requestParameters, initOverrides);
    }

    /**
     * Get statistics including counts by status, costs, revenue, and profit.
     * Get inventory statistics
     */
    async adminInventoryControllerGetStatsRaw(requestParameters: AdminInventoryControllerGetStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryStatsDto>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerGetStats().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory/stats`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryStatsDtoFromJSON(jsonValue));
    }

    /**
     * Get statistics including counts by status, costs, revenue, and profit.
     * Get inventory statistics
     */
    async adminInventoryControllerGetStats(requestParameters: AdminInventoryControllerGetStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryStatsDto> {
        const response = await this.adminInventoryControllerGetStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get paginated list of inventory items with optional filtering by status and supplier.
     * List inventory items
     */
    async adminInventoryControllerListItemsRaw(requestParameters: AdminInventoryControllerListItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedInventoryDto>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerListItems().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['supplier'] != null) {
            queryParameters['supplier'] = requestParameters['supplier'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sortBy'] = requestParameters['sortBy'];
        }

        if (requestParameters['sortDir'] != null) {
            queryParameters['sortDir'] = requestParameters['sortDir'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedInventoryDtoFromJSON(jsonValue));
    }

    /**
     * Get paginated list of inventory items with optional filtering by status and supplier.
     * List inventory items
     */
    async adminInventoryControllerListItems(requestParameters: AdminInventoryControllerListItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedInventoryDto> {
        const response = await this.adminInventoryControllerListItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark an item as invalid (with reason) or restore it to available. Cannot modify sold items.
     * Update item status
     */
    async adminInventoryControllerUpdateStatusRaw(requestParameters: AdminInventoryControllerUpdateStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryItemResponseDto>> {
        if (requestParameters['productId'] == null) {
            throw new runtime.RequiredError(
                'productId',
                'Required parameter "productId" was null or undefined when calling adminInventoryControllerUpdateStatus().'
            );
        }

        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling adminInventoryControllerUpdateStatus().'
            );
        }

        if (requestParameters['updateItemStatusDto'] == null) {
            throw new runtime.RequiredError(
                'updateItemStatusDto',
                'Required parameter "updateItemStatusDto" was null or undefined when calling adminInventoryControllerUpdateStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/admin/products/{productId}/inventory/{itemId}/status`;
        urlPath = urlPath.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters['productId'])));
        urlPath = urlPath.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters['itemId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateItemStatusDtoToJSON(requestParameters['updateItemStatusDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryItemResponseDtoFromJSON(jsonValue));
    }

    /**
     * Mark an item as invalid (with reason) or restore it to available. Cannot modify sold items.
     * Update item status
     */
    async adminInventoryControllerUpdateStatus(requestParameters: AdminInventoryControllerUpdateStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryItemResponseDto> {
        const response = await this.adminInventoryControllerUpdateStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const AdminInventoryControllerListItemsStatusEnum = {
    Available: 'available',
    Reserved: 'reserved',
    Sold: 'sold',
    Expired: 'expired',
    Invalid: 'invalid'
} as const;
export type AdminInventoryControllerListItemsStatusEnum = typeof AdminInventoryControllerListItemsStatusEnum[keyof typeof AdminInventoryControllerListItemsStatusEnum];
/**
 * @export
 */
export const AdminInventoryControllerListItemsSortByEnum = {
    UploadedAt: 'uploadedAt',
    SoldAt: 'soldAt',
    ExpiresAt: 'expiresAt',
    Cost: 'cost'
} as const;
export type AdminInventoryControllerListItemsSortByEnum = typeof AdminInventoryControllerListItemsSortByEnum[keyof typeof AdminInventoryControllerListItemsSortByEnum];
/**
 * @export
 */
export const AdminInventoryControllerListItemsSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AdminInventoryControllerListItemsSortDirEnum = typeof AdminInventoryControllerListItemsSortDirEnum[keyof typeof AdminInventoryControllerListItemsSortDirEnum];
